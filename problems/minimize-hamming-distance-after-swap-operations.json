{
  "problemName": "minimize-hamming-distance-after-swap-operations",
  "language": "java",
  "code": "class Solution {\n    public int minHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {\n        int n = source.length;\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        for (int[] swap : allowedSwaps) {\n            int u = swap[0];\n            int v = swap[1];\n            int rootU = find(parent, u);\n            int rootV = find(parent, v);\n            if (rootU != rootV) {\n                parent[rootU] = rootV;\n            }\n        }\n        Map<Integer, List<Integer>> groups = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int root = find(parent, i);\n            groups.computeIfAbsent(root, k -> new ArrayList<>()).add(i);\n        }\n        int hammingDistance = 0;\n        for (List<Integer> group : groups.values()) {\n            Map<Integer, Integer> sourceCounts = new HashMap<>();\n            Map<Integer, Integer> targetCounts = new HashMap<>();\n            for (int index : group) {\n                sourceCounts.put(source[index], sourceCounts.getOrDefault(source[index], 0) + 1);\n                targetCounts.put(target[index], targetCounts.getOrDefault(target[index], 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : sourceCounts.entrySet()) {\n                int num = entry.getKey();\n                int count = entry.getValue();\n                if (targetCounts.containsKey(num)) {\n                    int common = Math.min(count, targetCounts.get(num));\n                    sourceCounts.put(num, sourceCounts.get(num) - common);\n                    targetCounts.put(num, targetCounts.get(num) - common);\n                }\n            }\n            for (int index : group) {\n                if (sourceCounts.containsKey(source[index]) && sourceCounts.get(source[index]) > 0) {\n                    hammingDistance++;\n                    sourceCounts.put(source[index], sourceCounts.get(source[index]) - 1);\n                }\n            }\n        }\n        return hammingDistance;\n    }\n    private int find(int[] parent, int i) {\n        if (parent[i] == i) {\n            return i;\n        }\n        return parent[i] = find(parent, parent[i]);\n    }\n}",
  "generatedBy": "gemini-ai",
  "timestamp": "2025-08-09T10:12:07.826Z"
}