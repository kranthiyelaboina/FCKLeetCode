{
  "problemName": "build-a-matrix-with-conditions",
  "language": "java",
  "code": "class Solution {\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\n        List<Integer>[] rowAdj = new List[k + 1];\n        List<Integer>[] colAdj = new List[k + 1];\n        for (int i = 1; i <= k; i++) {\n            rowAdj[i] = new ArrayList<>();\n            colAdj[i] = new ArrayList<>();\n        }\n        int[] rowInDegree = new int[k + 1];\n        int[] colInDegree = new int[k + 1];\n        for (int[] condition : rowConditions) {\n            rowAdj[condition[1]].add(condition[0]);\n            rowInDegree[condition[0]]++;\n        }\n        for (int[] condition : colConditions) {\n            colAdj[condition[1]].add(condition[0]);\n            colInDegree[condition[0]]++;\n        }\n        List<Integer> rowOrder = topologicalSort(k, rowAdj, rowInDegree);\n        List<Integer> colOrder = topologicalSort(k, colAdj, colInDegree);\n        if (rowOrder.size() != k || colOrder.size() != k) {\n            return new int[0][0];\n        }\n        int[] rowPos = new int[k + 1];\n        int[] colPos = new int[k + 1];\n        for (int i = 0; i < k; i++) {\n            rowPos[rowOrder.get(i)] = i;\n            colPos[colOrder.get(i)] = i;\n        }\n        int[][] result = new int[k][k];\n        for (int i = 1; i <= k; i++) {\n            result[rowPos[i]][colPos[i]] = i;\n        }\n        return result;\n    }\n    private List<Integer> topologicalSort(int k, List<Integer>[] adj, int[] inDegree) {\n        List<Integer> result = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= k; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            result.add(node);\n            for (int neighbor : adj[node]) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        return result;\n    }\n}",
  "generatedBy": "gemini-ai",
  "timestamp": "2025-08-09T10:13:37.022Z"
}